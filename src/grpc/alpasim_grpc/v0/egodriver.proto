// SPDX-License-Identifier: Apache-2.0
// Copyright (c) 2025 NVIDIA Corporation

syntax = "proto3";

package egodriver;

import "alpasim_grpc/v0/common.proto";
import "alpasim_grpc/v0/sensorsim.proto";

service EgodriverService {
    rpc start_session (DriveSessionRequest) returns (common.SessionRequestStatus);
    rpc close_session (DriveSessionCloseRequest) returns (common.Empty);
    rpc submit_image_observation (RolloutCameraImage) returns (common.Empty);
    rpc submit_egomotion_observation (RolloutEgoTrajectory) returns (common.Empty);
    rpc submit_route (RouteRequest) returns (common.Empty);
    rpc submit_recording_ground_truth (GroundTruthRequest) returns (common.Empty);
    rpc drive (DriveRequest) returns (DriveResponse);
    rpc get_version (common.Empty) returns (common.VersionId);
    rpc shut_down (common.Empty) returns (common.Empty);
}

message Route {
    // Timestamp at which the message is valid.
    fixed64 timestamp_us = 2;
    // Waypoints for a route expressed in the rig frame at this timestamp (see CONTRIBUTING.md, "Coordinate Systems").
    repeated common.Vec3 waypoints = 1;
}

message GroundTruth {
    // Timestamp at which the message is valid.
    fixed64 timestamp_us = 2;
    // Ground-truth trajectory from the recording (actual path followed by the real car).
    // Each pose is expressed in the rig frame at the provided timestamp (see CONTRIBUTING.md, "Coordinate Systems").
    common.Trajectory trajectory = 1;
}

message DriveSessionRequest {
    message RolloutSpec {
        message VehicleDefinition {
            repeated nre.grpc.protos.sensorsim.AvailableCamerasReturn.AvailableCamera available_cameras = 3;
        }

        VehicleDefinition vehicle = 1;
    }

    string session_uuid = 1;
    fixed64 random_seed = 2;

    message DebugInfo {
        string scene_id = 1;
    }

    // will not be present in benchmark runs to avoid any potential data leakage
    optional DebugInfo debug_info = 4;

    RolloutSpec rollout_spec = 5;
}

message DriveSessionCloseRequest {
    string session_uuid = 1;
}

message RolloutCameraImage {
    message CameraImage {
        fixed64 frame_start_us = 2;
        fixed64 frame_end_us = 3;
        bytes image_bytes = 4;
        string logical_id = 5;
    }

    string session_uuid = 1;
    CameraImage camera_image = 3;
}

message RolloutEgoTrajectory {
    string session_uuid = 1;
    /// Estimated ego rig pose as the active transform local->rig_est (see CONTRIBUTING.md, "Coordinate Systems").
    /// Note: this can diverge from the true local->rig transform when error models are enabled.
    common.Trajectory trajectory = 3;
}

message RouteRequest {
    string session_uuid = 1;
    Route route = 3; // Waypoints are defined in the rig frame at the accompanying timestamp.
}

message GroundTruthRequest {
    string session_uuid = 1;
    GroundTruth ground_truth = 2;
}

message DriveRequest {
    message RolloutDriveRequest {
        fixed64 time_now_us = 1;
        fixed64 time_query_us = 2;
    }

    string session_uuid = 1;

    fixed64 time_now_us = 3;
    fixed64 time_query_us = 4;
    bytes renderer_data = 5; // optional, can be used to provide the driver arbitrary data produced by the renderer
}

message DriveResponse {
    // The drive_response trajectory stores the active transform local->rig_est produced by the driver (see CONTRIBUTING.md, "Coordinate Systems").
    common.Trajectory trajectory = 2;
    message DebugInfo {
        // for iteration speed, the implementer of egodriver can choose to log arbitrary binary messages
        // for which they write their own (de)serialization. Once proven to be useful they may be
        // stabilized in proto.
        bytes unstructured_debug_info = 1;

        repeated common.Trajectory sampled_trajectories = 2;
    }

    DebugInfo debug_info = 3;
}
